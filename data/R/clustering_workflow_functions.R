# ===============================================================================
# FUNCIONES ESPECÍFICAS PARA WORKFLOW DE CLUSTERING
# ===============================================================================

#' Generate automatic clustering from rollcall matrix
#'
#' @description
#' Creates clustering assignments from rollcall data using distance-based algorithm.
#' Generates a new legislators dataframe with cluster assignments that can be used for B-Call.
#'
#' @param rollcall_data Output from excel_to_rollcall() function
#' @param distance_method Integer, distance metric (1 = Manhattan, 2 = Euclidean)
#' @param pivot Character, pivot legislator name (NULL for automatic selection)
#' @param verbose Logical, whether to print progress messages
#'
#' @return Modified rollcall_data with new clustering in legislators_info
#'
#' @examples
#' \dontrun{
#' rollcall_data <- excel_to_rollcall("legis.xlsx", "votos.xlsx")
#' rollcall_with_clusters <- generate_clustering_from_rollcall(rollcall_data)
#' }
#'
#' @export
generate_clustering_from_rollcall <- function(rollcall_data, distance_method = 1, pivot = NULL, verbose = TRUE) {

  if (!inherits(rollcall_data, "list") ||
      !all(c("rollcall_matrix", "legislators_info") %in% names(rollcall_data))) {
    stop("rollcall_data debe ser el resultado de excel_to_rollcall()")
  }

  if (verbose) cat("=== GENERANDO CLUSTERING DESDE ROLLCALL ===\n")

  rollcall_matrix <- rollcall_data$rollcall_matrix
  legislators_info <- rollcall_data$legislators_info

  if (verbose) {
    cat("   - Matriz rollcall:", nrow(rollcall_matrix), "legisladores x", ncol(rollcall_matrix), "votaciones\n")
    distance_name <- if(distance_method == 1) "Manhattan" else if(distance_method == 2) "Euclidiana" else "Desconocida"
    cat("   - Método de distancia:", distance_name, "(N =", distance_method, ")\n")
  }

  # Selección automática de pivot si no se especifica
  if (is.null(pivot)) {
    pivot <- rownames(rollcall_matrix)[1]
    if (verbose) cat("   - Pivot seleccionado automáticamente:", pivot, "\n")
  } else {
    if (verbose) cat("   - Pivot especificado:", pivot, "\n")
  }

  # Crear objeto clustering
  if (verbose) cat("   - Ejecutando algoritmo de clustering...\n")
  clustering_obj <- Clustering$new(
    rollcalls = rollcall_matrix,
    N = distance_method,
    pivot = pivot
  )

  # Obtener clustering resultados
  clustering_df <- clustering_obj$clustering

  if (verbose) {
    cat("   - Distribución de clusters generados:\n")
    cluster_table <- table(clustering_df$cluster)
    for (cluster_name in names(cluster_table)) {
      cat("     *", cluster_name, ":", cluster_table[cluster_name], "legisladores\n")
    }
  }

  # Actualizar legislators_info con nuevos clusters
  # Mantener columnas originales y agregar columna de cluster automático
  updated_legislators <- legislators_info

  # Hacer merge para agregar clusters automáticos
  clustering_df$nm_y_apellidos <- rownames(clustering_df)
  updated_legislators <- merge(updated_legislators, clustering_df, by = "nm_y_apellidos", all.x = TRUE)

  # Renombrar columna para claridad
  names(updated_legislators)[names(updated_legislators) == "cluster"] <- "auto_cluster"

  # Crear nueva versión de rollcall_data con clustering actualizado
  result <- rollcall_data
  result$legislators_info <- updated_legislators
  result$clustering_metadata <- list(
    distance_method = distance_method,
    distance_name = distance_name,
    pivot_used = pivot,
    clustering_date = Sys.time(),
    original_party_column = if("party" %in% names(legislators_info)) "party" else NULL
  )

  if (verbose) {
    cat("✅ CLUSTERING GENERADO\n")
    cat("   - Nueva columna 'auto_cluster' agregada a legislators_info\n")
    if ("party" %in% names(legislators_info)) {
      cat("   - Columna 'party' original preservada para comparación\n")
    }
    cat("   - Datos listos para run_bcall_with_auto_clusters()\n")
  }

  return(result)
}

#' Run B-Call analysis using automatic clusters
#'
#' @description
#' Executes B-Call analysis using the automatic clustering generated by generate_clustering_from_rollcall().
#' Uses the 'auto_cluster' column instead of the original 'party' column.
#'
#' @param rollcall_data_with_clusters Output from generate_clustering_from_rollcall()
#' @param pivot Character, pivot legislator name (NULL for automatic selection from 'right' cluster)
#' @param threshold Numeric, minimum participation threshold (0.0-1.0)
#' @param verbose Logical, whether to print progress messages
#'
#' @return B-Call analysis results using automatic clustering
#'
#' @examples
#' \dontrun{
#' rollcall_data <- excel_to_rollcall("legis.xlsx", "votos.xlsx")
#' rollcall_with_clusters <- generate_clustering_from_rollcall(rollcall_data)
#' results <- run_bcall_with_auto_clusters(rollcall_with_clusters)
#' }
#'
#' @export
run_bcall_with_auto_clusters <- function(rollcall_data_with_clusters, pivot = NULL, threshold = 0.1, verbose = TRUE) {

  if (!inherits(rollcall_data_with_clusters, "list") ||
      !all(c("rollcall_matrix", "legislators_info") %in% names(rollcall_data_with_clusters))) {
    stop("rollcall_data_with_clusters debe ser el resultado de generate_clustering_from_rollcall()")
  }

  if (!"auto_cluster" %in% names(rollcall_data_with_clusters$legislators_info)) {
    stop("No se encontró columna 'auto_cluster'. Ejecute primero generate_clustering_from_rollcall()")
  }

  if (verbose) cat("=== EJECUTANDO B-CALL CON CLUSTERING AUTOMÁTICO ===\n")

  rollcall_matrix <- rollcall_data_with_clusters$rollcall_matrix
  legislators_info <- rollcall_data_with_clusters$legislators_info

  # Crear DataFrame de clustering desde auto_cluster (en lugar de party)
  clustering_df <- data.frame(
    cluster = legislators_info$auto_cluster,
    row.names = legislators_info$nm_y_apellidos
  )

  # Verificar que clustering_df tenga exactamente los mismos legisladores que rollcall_matrix
  common_legislators <- intersect(rownames(rollcall_matrix), rownames(clustering_df))

  if (length(common_legislators) == 0) {
    stop("No hay legisladores comunes entre rollcall_matrix y clustering automático")
  }

  # Filtrar para que coincidan
  rollcall_matrix <- rollcall_matrix[common_legislators, ]
  clustering_df <- clustering_df[common_legislators, , drop = FALSE]

  if (verbose) {
    cat("   - Matriz rollcall:", nrow(rollcall_matrix), "legisladores x", ncol(rollcall_matrix), "votaciones\n")
    cat("   - Clustering automático:", nrow(clustering_df), "legisladores en", length(unique(clustering_df$cluster)), "clusters\n")
    cat("   - Distribución de clusters:\n")
    cluster_table <- table(clustering_df$cluster)
    for (cluster_name in names(cluster_table)) {
      cat("     *", cluster_name, ":", cluster_table[cluster_name], "legisladores\n")
    }
  }

  # Seleccionar pivot automáticamente si no se especifica
  if (is.null(pivot)) {
    # Buscar un legislador del cluster "right" con alta participación
    right_legislators <- rownames(clustering_df)[clustering_df$cluster == "right"]

    if (length(right_legislators) > 0) {
      # Calcular participación para legisladores de derecha
      participation <- 1 - rowSums(is.na(rollcall_matrix[right_legislators, , drop = FALSE])) / ncol(rollcall_matrix)
      pivot <- names(participation)[which.max(participation)]
      if (verbose) cat("   - Pivot seleccionado automáticamente (cluster 'right'):", pivot, "\n")
    } else {
      stop("No se encontraron legisladores en el cluster 'right' para seleccionar pivot automáticamente")
    }
  } else {
    if (verbose) cat("   - Pivot especificado:", pivot, "\n")
  }

  if (is.null(pivot)) {
    stop("Debe especificar un pivot o usar selección automática")
  }

  # Crear objeto BCall
  if (verbose) cat("   - Creando objeto BCall con clustering automático...\n")
  bcall_obj <- BCall$new(
    rollcall = rollcall_matrix,
    clustering = clustering_df,
    pivot = pivot,
    threshold = threshold
  )

  # Extraer resultados
  results_df <- bcall_obj$stats
  results_df$nm_y_apellidos <- rownames(results_df)

  # Agregar información completa de legisladores (incluyendo auto_cluster y party si existe)
  results_df <- merge(results_df, legislators_info, by = "nm_y_apellidos", all.x = TRUE)

  # Crear estructura de resultado compatible
  result <- list(
    results = results_df,
    bcall_object = bcall_obj,
    rollcall_matrix = rollcall_matrix,
    clustering_df = clustering_df,
    metadata = list(
      clustering_method = "Automatic",
      distance_method = if("clustering_metadata" %in% names(rollcall_data_with_clusters)) rollcall_data_with_clusters$clustering_metadata$distance_method else "Unknown",
      pivot_used = pivot,
      threshold_used = threshold,
      legislators_count = nrow(rollcall_matrix),
      votaciones_count = ncol(rollcall_matrix),
      analysis_date = Sys.time(),
      cluster_column_used = "auto_cluster"
    )
  )

  if (verbose) {
    cat("✅ ANÁLISIS B-CALL COMPLETADO\n")
    cat("   - d1 (posición ideológica): rango [", round(min(results_df$d1, na.rm = TRUE), 3),
        ", ", round(max(results_df$d1, na.rm = TRUE), 3), "]\n")
    cat("   - d2 (cohesión política): rango [", round(min(results_df$d2, na.rm = TRUE), 3),
        ", ", round(max(results_df$d2, na.rm = TRUE), 3), "]\n")
    if ("party" %in% names(results_df) && "auto_cluster" %in% names(results_df)) {
      cat("   - Disponible comparación: party (original) vs auto_cluster (automático)\n")
    }
  }

  return(result)
}